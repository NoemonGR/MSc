# Υλοποιήστε σε γλώσσα προγραμματισμού της επιλογής σας, Ντετερμινιστικό Αυτόματο Στοίβας
# (ΝΑΣ) (DFA) που μοντελοποιεί εκφράσεις απoτελούμενες μόνο από δεξιές και αριστερές παρενθέσεις,
# κατά τρόπο ώστε:

# όσες αριστερές παρενθέσεις ανοίγουν συνολικά, τόσες κλείνουν και κοιτάζοντας την έκφραση από
# αριστερά προς τα δεξιά, οι δεξιές παρενθέσεις δεν είναι ποτέ περισσότερες από τις αριστερές.

# Για παράδειγμα, η έκφραση (())() αναγνωρίζεται από το ΝΑΣ, αλλά η ())( δεν αναγνωρίζεται.

# Το πρόγραμμά σας θα δέχεται είσοδο μία έκφραση κάθε φορά και θα επιστρέφει την ένδειξη
# «YES» ή «NO», ανάλογα με το αν η συμβολοσειρά αναγνωρίζεται ή όχι. Επίσης θα τυπώνεται η
# αλληλουχία βημάτων που οδήγησαν στην αναγνώριση (ή στην απόρριψη) της έκφρασης. Σε κάθε
# γραμμή εκτύπωσης θα παρουσιάζονται τα περιεχόμενα της στοίβας, η τρέχουσα κατάσταση και τα
# υπόλοιπα σύμβολα εισόδου.

# ΠΡΟΣΟΧΗ: Όπου αριστερή παρένθεση το πρώτο γράμμα του επιθέτου ενός εκ των
# φοιτητών/φοιτητριών της ομάδας (επιλέξτε). Όπου δεξιά παρένθεση το πρώτο γράμμα του
# επιθέτου ενός άλλου εκ των φοιτητών/φοιτητριών της ομάδας (επιλέξτε). Και τα δύο πρέπει
# να είναι σε αγγλικό αλφάβητο.

K = ["("] #open #Koutsoukoglou
A = [")"] #close #Aggelopoulos

# Example:
#     YES-->  (),(())
#     NO--->  )(,))((

x=input("Give Parenthesis String : ")

print("Analyzing Parenthesis String!")

def check(x):
    stack=[] #LIFO stack
    for i in x:
        if i in K:
            stack.append(i)
        elif i in A:
            pos=A.index(i)
            if ((len(stack)>0) and
                (K[pos]==stack[len(stack)-1])):
                print("Popped: ",stack.pop())
            else:
                return "NO"
    if len(stack)==0:
        return "YES"
    else:
        return "NO"

print("======================")
print(x,"-",check(x))
print("======================")